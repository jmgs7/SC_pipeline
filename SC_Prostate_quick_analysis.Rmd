---
title: "SC_Prostate_quick_analysis"
author: "José Manuel Gómez Silva"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}

all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))

knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE,
  echo = TRUE
)
```

# SC_Prostate_Run_1 analysis.

Analyiis of scRNA-seq data provided by Eduardo Andrés León (eduardo.andres\@csic.es, Instituto de Parasitología y Biología López Neyra, Granada). SC data was generated and pre-analysed sing BD Rhapsody systems and Illumina sequencers. BD includes pipelines for read mapping and putative cell filtering. An analysis using the Seurat package (<https://satijalab.org/seurat/>) was done by the CSIC staff using the seven bridges platform, but an obsolete normalization method was used. This R markdown file describes a preliminary analysis for the first of the four runs the project contains.

```{r libraries}

library(Seurat)
library(SeuratData)
library(dplyr)
library(patchwork)
library(sctransform)
library(ggplot2)
```

## 1. Import data and exploratory analysis.

Import data from RDS file provided by Eduardo Andrés León (eduardo.andres\@csic.es, Instituto de Parasitología y Biología López Neyra, Granada).

### 1.1. Raw counts.

```{r import_raw_data}

run1.raw <- readRDS("Data/run1/C1_Seurat.rds")
run1.raw
```

```{r data_exploration_raw}

run1.raw@meta.data[1:5,]

run1.raw[['RNA']]$counts[1:5,1:5]

head(colnames(run1.raw[['RNA']]$counts), 10)
# Cells are identified by an integer, not their UMI.
```

### 1.2. Pre-processed counts.

```{r import_data}

run1 <- readRDS("Data/run1/C1_Seurat_Edu.rds")
run1
```

```{r data_exploration}

run1@meta.data[1:5,]

run1[['RNA']]$counts[1:5,1:5]

head(colnames(run1[['RNA']]$counts), 10)
```

## 2. QC.

### 2.1. Mitochondrial gene percentage calculation.

```{r mito_genes}

run1.raw[['percent.mt']] <- PercentageFeatureSet(run1.raw, pattern = "^MT-")

run1.raw[['percent.mt']][1:5,]

```

### 2.2. QC visualization.

```{r QC_visualization, echo=FALSE, fig.height=6, fig.width=10}

#Visualize QC metrics as a violin plot
VlnPlot(run1.raw, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Zoom in on nCount_RNA violin plot.
VlnPlot(run1.raw, features = "nCount_RNA", ncol = 1) + ylim(0, 25000) + NoLegend()

#Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run1.raw, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(run1.raw, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + plot2

```

### 2.3. Filtering cells.

#### A. Filtering 1 % top and bottom percentiles.

```{r filtering_percentiles}

minCov=1000 #if a sample has a good coverage (>=minCov), then don't set a lower thresold for nCount, it's already pretty good. 
  if(min(run1.raw$nCount_RNA)>=minCov){
    countLOW=min(run1.raw$nCount_RNA)
  }else{
    countLOW=quantile(run1.raw$nCount_RNA, prob=c(0.01))  
 }
 countHIGH=quantile(run1.raw$nCount_RNA, prob=0.99)
 featureHIGH=quantile(run1.raw$nFeature_RNA, prob=0.99)
 featureLOW=quantile(run1.raw$nFeature_RNA, prob=0.01)

# subset
run1.subset <- subset(run1.raw, subset = nFeature_RNA > featureLOW & nFeature_RNA < featureHIGH & nCount_RNA > countLOW  & nCount_RNA < countHIGH & percent.mt < 25)

run1.subset
```

#### B. Filtering mean +- 2\*SD.

```{r filtering_SD}

# # Get filtering parameters
# count.max <- round(mean(run1.raw$nCount_RNA) + 2 * sd(run1.raw$nCount_RNA), digits = -2)
# count.min <- round(mean(run1.raw$nCount_RNA) - 2 * sd(run1.raw$nCount_RNA), digits = -2)
# feat.max <- round(mean(run1.raw$nFeature_RNA) + 2 * sd(run1.raw$nFeature_RNA), digits = -2)
# feat.min <- round(mean(run1.raw$nFeature_RNA) - 2 * sd(run1.raw$nFeature_RNA), digits = -2)
# 
# # Set minimum parameters to 0 if negative value
# if (count.min < 0){
#    count.min <- 0
# } else {
#    count.min <- count.min
# }
#   
# if (feat.min < 0){
#    feat.min <- 0
# } else {
#    feat.min <- feat.min
# }
# 
# ## Filter cells
# run1.subset <- subset(run1.raw, subset = nFeature_RNA > feat.min & nFeature_RNA < feat.max & nCount_RNA < count.max & nCount_RNA > count.min & percent.mt < 25)
# 
# run1.subset
```

#### 2.4. Normalization using SCTransform.

```{r SCTransform}

# Filtered using 2.3.A.: 1% top and bottom percentiles.

run1.subset <- SCTransform(run1.subset, vst.flavor = "v2", vars.to.regress = "percent.mt")
```

### 2.5. Visualizing QC parameters after normalization.

```{r QC_norm}

#Visualize QC metrics as a violin plot
VlnPlot(run1.subset, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Zoom in on nCount_RNA violin plot.
VlnPlot(run1.subset, features = "nCount_RNA", ncol = 1) + ylim(0, 25000) + NoLegend()

#Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run1.subset, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(run1.subset, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + plot2

```

## 3. Identification of highly variable features (feature selection).

```{r var_features, fig.height=6, fig.width=10}

run1.subset <- FindVariableFeatures(run1.subset, selection.method = 'vst', nfeatures = 2000)

# Genes with differencial expression in different cells are good candidates to be biomarkers.
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(run1.subset), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(run1.subset)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```

## 4. Linear dimensional reduction (PCA).

```{r PCA, echo=FALSE, fig.height=6, fig.width=6}

run1.subset <- RunPCA(run1.subset) #features = VariableFeatures(object = run1.subset))

DimPlot(run1.subset, reduction = 'pca') + NoLegend() # An unique PCA is not enough to separate cell groups.

ElbowPlot(run1.subset)
```

```{r PCA_heatmap, echo = FALSE, fig.height=15, fig.width=10}

DimHeatmap(run1.subset, dims = 1:20, balanced = TRUE)
```

```{r PCA_top_features, echo = FALSE, fig.height=30, fig.width=15}

VizDimLoadings(run1.subset, dims = 1:20, reduction = 'pca')
```

## 5. Clustering

```{r clustering}
run1.subset <- FindNeighbors(run1.subset, dims = 1:20)
run1.subset <- FindClusters(run1.subset) # Default resolution = 0.8
```

```{r cluster_visualization, echo=FALSE}

run1.subset <- RunUMAP(run1.subset, dims = 1:20)
DimPlot(run1.subset, reduction = 'umap', label = TRUE)
```

```{r saving_data, eval=FALSE}

saveRDS(run1, file = "Ouput/output_from_raw.rds")
```

# Data analysis using pre-processed data.

```{r oneliner, echo=FALSE}

run1 <- readRDS("Data/run1/C1_Seurat_Edu.rds") %>% PercentageFeatureSet(pattern = "^MT-", col.name = 'percent.mt') %>% SCTransform(vst.flavor = "v2", vars.to.regress = 'percent.mt') %>% RunPCA(assay = "SCT") %>% FindNeighbors(dims = 1:20) %>% RunUMAP(dims = 1:20) %>% FindClusters()

DimPlot(run1, label = TRUE)
```

```{r}

ElbowPlot(run1, ndims = 50, reduction = 'pca')
```
