---
title: "SC_Prostate_quick_analysis"
author: "José Manuel Gómez Silva"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}

all_times <- list()  # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))

knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE,
  echo = TRUE,
  engine.opts = list(bash = "-l")
)
```

# SC_Prostate_Run_1 analysis.

Analyiis of scRNA-seq data provided by Eduardo Andrés León (eduardo.andres\@csic.es, Instituto de Parasitología y Biología López Neyra, Granada). SC data was generated and pre-analysed sing BD Rhapsody systems and Illumina sequencers. BD includes pipelines for read mapping and putative cell filtering. An analysis using the Seurat package (<https://satijalab.org/seurat/>) was done by the CSIC staff using the seven bridges platform, but an obsolete normalization method was used. This R markdown file describes a preliminary analysis for the first of the four runs the project contains.

```{r libraries, include = FALSE}

library(Seurat)
library(dplyr)
library(patchwork)
library(sctransform)
library(ggplot2)
library(celldex) # Cell annotation.
library(SingleR) # Cell annotation.
library(parallel)  # detectCores()
library(future) # Allows parallelization in Seurat.
# library(SeuratData) # Allows file conversion for the CellBender pipeline.
# library(DoubletFinder) # Remove multiplets. Not aplicable to mixed samples.
# library(DropletUtils) # File conversion for CellBender.

# Set up Seurat pararell computing.
options(parallelly.fork.enable = TRUE)
plan("multicore", workers = detectCores())
```

## 1. Import data and exploratory analysis.

Import data from RDS file provided by Eduardo Andrés León (eduardo.andres\@csic.es, Instituto de Parasitología y Biología López Neyra, Granada).

### 1.1. Raw counts.

```{r import_raw_data}

run1.raw <- readRDS("../Data/run1/C1_Seurat.rds")
run1.raw
```

```{r data_exploration_raw}

run1.raw@meta.data[1:5,]

run1.raw[['RNA']]$counts[1:5,1:5]

head(colnames(run1.raw[['RNA']]$counts), 10)
# Cells are identified by an integer, not their UMI.
```

Export data to h5 format to use in CellBender.

```{r export_h5e}
# write10xCounts("../Data/run1/run1_raw.h5", run1.raw@assays$RNA@counts)
```

Call CellBender from system to remove background RNA (WARNING: Computationally expensive. Run in HPC server and enable the - - cuda option when possible)

!! Problems: Need parameter adjusting. Data presents serious degradation and a high % of mitochondrial genes, so the deep learning algorithms implemented in CellBender caputures a large amount of counts as ambient RNA, causing a severe cell number reduction after filtering.

Particularization is extremely expensive as we need to run the inference process multiple time for each parameter iteration in the optimization process. Also, no GPU acceleration is available.

```{bash engine.opts='-l'}

# ~/anaconda3/envs/cellbender/bin/cellbender remove-background --input "../Data/run1/run1_raw.h5" --output "../Data/run1/run1_raw_clean.h5"

# ~/anaconda3/envs/cellbender/bin/ptrepack --complevel 5 "../Data/run1/run1_clean.h5":/matrix "../Data/run1/run1_clean_seurat.h5":/matrix
```

```{r load_clean}

# run1.raw <- Read10X_h5(filename = "../Data/run1/run1_clean_seurat.h5")
# run1.raw <- CreateSeuratObject(run1.raw)
# run1.raw
```

### 1.2. Pre-processed counts.

```{r import_data}

run1 <- readRDS("../Data/run1/C1_Seurat_Edu.rds")
run1
```

```{r data_exploration}

run1@meta.data[1:5,]

run1[['RNA']]$counts[1:5,1:5]

head(colnames(run1[['RNA']]$counts), 10)
```

## 2. QC.

### 2.1. Mitochondrial gene percentage calculation.

```{r mito_genes}

run1.raw[['percent.mt']] <- PercentageFeatureSet(run1.raw, pattern = "^MT-")

run1.raw[['percent.mt']][1:5,]
```

### 2.2. QC visualization.

```{r QC_visualization, fig.height=6, fig.width=10}

#Visualize QC metrics as a violin plot
VlnPlot(run1.raw, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Zoom in on nFeature_RNA violin plot.
VlnPlot(run1.raw, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()

#Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run1.raw, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(run1.raw, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + plot2

```

### 2.3. Filtering cells.

#### A. Filtering 1 % top and bottom percentiles.

```{r filtering_percentiles}

# Remove Undetermined and multiplets.
run1.subset <- subset(run1.raw, Sample_Tag != "Undetermined" & Sample_Name != "Multiplet")

minCov=1000 #if a sample has a good coverage (>=minCov), then don't set a lower thresold for nCount, it's already pretty good. 
  if(min(run1.subset$nCount_RNA)>=minCov){
    countLOW=min(run1.subset$nCount_RNA)
  }else{
    countLOW=quantile(run1.subset$nCount_RNA, prob=c(0.01))  
 }
 countHIGH=quantile(run1.subset$nCount_RNA, prob=0.99)
 featureHIGH=quantile(run1.subset$nFeature_RNA, prob=0.99)
 featureLOW=quantile(run1.subset$nFeature_RNA, prob=0.01)

# subset
run1.subset <- subset(run1.subset, subset = nFeature_RNA > featureLOW & nFeature_RNA < featureHIGH & nCount_RNA > countLOW  & nCount_RNA < countHIGH & percent.mt < 25)

run1.subset
```

#### B. Filtering mean +- 2\*SD.

```{r filtering_SD}

# # Get filtering parameters
# count.max <- round(mean(run1.raw$nCount_RNA) + 2 * sd(run1.raw$nCount_RNA), digits = -2)
# count.min <- round(mean(run1.raw$nCount_RNA) - 2 * sd(run1.raw$nCount_RNA), digits = -2)
# feat.max <- round(mean(run1.raw$nFeature_RNA) + 2 * sd(run1.raw$nFeature_RNA), digits = -2)
# feat.min <- round(mean(run1.raw$nFeature_RNA) - 2 * sd(run1.raw$nFeature_RNA), digits = -2)
# 
# # Set minimum parameters to 0 if negative value
# if (count.min < 0){
#    count.min <- 0
# } else {
#    count.min <- count.min
# }
#   
# if (feat.min < 0){
#    feat.min <- 0
# } else {
#    feat.min <- feat.min
# }
# 
# ## Filter cells
# run1.subset <- subset(run1.raw, subset = nFeature_RNA > feat.min & nFeature_RNA < feat.max & nCount_RNA < count.max & nCount_RNA > count.min & percent.mt < 25)
# 
# run1.subset
```

#### C. Custom filtering.

```{r filtering_custom}

# # Using parameters estimated by Edu.
# 
# run1.subset <- subset(run1.raw, subset = nFeature_RNA > 91.585 & nFeature_RNA < 7846.18 & percent.mt < 25)
# 
# run1.subset
```

### 2.4. Normalization using SCTransform.

```{r SCTransform}

# Filtered using 2.3.A.: 1% top and bottom percentiles, removing undetermined and multiplets.

run1.subset <- SCTransform(run1.subset, vst.flavor = "v2", vars.to.regress = "percent.mt")
```

### 2.5. Visualizing QC parameters after normalization.

```{r QC_norm, fig.height=6, fig.width=10}

#Visualize QC metrics as a violin plot
VlnPlot(run1.subset, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Zoom in on nCount_RNA violin plot.
VlnPlot(run1.subset, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500)

#Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run1.subset, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(run1.subset, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + plot2

```

## 3. Identification of highly variable features (feature selection).

```{r var_features, fig.height=6, fig.width=10}

run1.subset <- FindVariableFeatures(run1.subset, selection.method = 'vst', nfeatures = 2000)

# Genes with differencial expression in different cells are good candidates to be biomarkers.
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(run1.subset), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(run1.subset)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot1 + plot2
```

## 4. Linear dimensional reduction (PCA).

```{r PCA, fig.height=6, fig.width=10}

run1.subset <- RunPCA(run1.subset) #features = VariableFeatures(object = run1.subset))

DimPlot(run1.subset, reduction = 'pca') + NoLegend() # An unique PCA is not enough to separate cell groups.

ElbowPlot(run1.subset, ndims = 50)
```

```{r PCA_heatmap, fig.height=15, fig.width=10}

DimHeatmap(run1.subset, dims = 1:30, balanced = TRUE)
```

```{r PCA_top_features, fig.height=30, fig.width=15}

VizDimLoadings(run1.subset, dims = 1:30, reduction = 'pca')
```

## 5. Clustering

```{r clustering}
run1.subset <- FindNeighbors(run1.subset, dims = 1:30)
run1.subset <- FindClusters(run1.subset, resolution = 0.8) # Default resolution = 0.8
run1.subset <- RunUMAP(run1.subset, dims = 1:30)
```

```{r cluster_visualization, fig.height=6, fig.width=10}

DimPlot(run1.subset, reduction = 'umap', label = TRUE)
```

Cluster QC.

```{r cluster_QC, fig.height=6, fig.width=10}

#Visualize QC metrics as a violin plot
VlnPlot(run1.subset, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) + NoLegend()

# Zoom in on nFeature_RNA violin plot.
VlnPlot(run1.subset, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()

#Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run1.subset, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(run1.subset, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + NoLegend() + plot2 + NoLegend()
```

```{r saving_data, eval = FALSE, echo = FALSE}

saveRDS(run1, file = "../Output/Run1_raw.rds")
```

## 6. Annotation.

Cell annotation is performed using the Human Cell Atlas as reference.

```{r annotation}

reference <- HumanPrimaryCellAtlasData()

run1.subset.SCexp <- as.SingleCellExperiment(run1.subset)

SingleR.annotation <- SingleR(test = run1.subset.SCexp, ref = reference, assay.type.test='counts', labels = reference$label.main, num.threads = detectCores())

run1.subset[["cell.labels"]] <- SingleR.annotation$labels
```

```{r annotation_vis, fig.height=6, fig.width=10}

DimPlot(run1.subset, reduction = 'umap', group.by = 'cell.labels', label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
```

By cluster annotation:

```{r cluster_annotation}

clusters <- run1.subset@meta.data[["seurat_clusters"]]
clusters <- as.character(levels(clusters)[clusters])


# reference <- HumanPrimaryCellAtlasData()

run1.subset.SCexp <- as.SingleCellExperiment(run1.subset)

SingleR.annotation <- SingleR(test = run1.subset.SCexp, ref = reference, assay.type.test='counts', labels = reference$label.main, clusters = clusters, num.threads = detectCores())

run1.subset[["cluster.labels"]] <- SingleR.annotation$labels
```

```{r set_ids}

cluster_number <- levels(run1.subset[["seurat_clusters"]][1,])
cluster_annotation <- SingleR.annotation$labels

new.clusters.ids <- paste0(cluster_number, "-", cluster_annotation)
names(new.clusters.ids) <- levels(run1.subset)
run1.subset <- RenameIdents(run1.subset, new.clusters.ids)
```

```{r cluster_annotation_vis, fig.height=6, fig.width=10}

DimPlot(run1.subset, reduction = 'umap', label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
```

# Data analysis using pre-processed data.

```{r oneliner, fig.height=6, fig.width=10}

run1 <- readRDS("../Data/run1/C1_Seurat_Edu.rds") %>% PercentageFeatureSet(pattern = "^MT-", col.name = 'percent.mt') %>% SCTransform(vst.flavor = "v2", vars.to.regress = 'percent.mt') %>% RunPCA(assay = "SCT") %>% FindNeighbors(dims = 1:30) %>% FindClusters(resolution = 0.8) %>% RunUMAP(dims = 1:30)
```

```{r  oneliner_clusters, fig.height=6, fig.width=10}

DimPlot(run1, reduction = 'umap', label = TRUE)
```

```{r oneliner_QC, fig.height=6, fig.width=10}

#Visualize QC metrics as a violin plot
VlnPlot(run1, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) + NoLegend()

# Zoom in on nFeature_RNA violin plot.
VlnPlot(run1, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()

#Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run1, feature1 = "nCount_RNA", feature2 = "percent.mt") 
plot2 <- FeatureScatter(run1, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") 
plot1 + NoLegend() + plot2 + NoLegend()
```

```{r PCA_Edu, fig.height=6, fig.width=10}

ElbowPlot(run1, ndims = 50)
```

```{r pre_annotation}

# reference <- HumanPrimaryCellAtlasData()

run1.SCexp <- as.SingleCellExperiment(run1)

SingleR.annotation <- SingleR(test = run1.SCexp, ref = reference, assay.type.test = 'counts', labels = reference$label.main, num.threads = detectCores()) 

run1[["cell.labels"]] <- SingleR.annotation$labels
```

```{r pre_annotation_vis, fig.height=6, fig.width=10}
DimPlot(run1, reduction = 'umap', group.by = 'cell.labels', label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
```

```{r pre_cluster_annotation}

clusters <- run1@meta.data[["seurat_clusters"]]
clusters <- as.character(levels(clusters)[clusters])

# reference <- HumanPrimaryCellAtlasData()

run1.SCexp <- as.SingleCellExperiment(run1)

SingleR.annotation <- SingleR(test = run1.SCexp, ref = reference, assay.type.test='counts', labels = reference$label.main, clusters = clusters, num.threads = detectCores())

run1[["cluster.labels"]] <- SingleR.annotation$labels

```

```{r pre_cluster_ids}

cluster_number <- levels(run1[["seurat_clusters"]][1,])
cluster_annotation <- SingleR.annotation$labels

new.clusters.ids <- paste0(cluster_number, "-", cluster_annotation)
names(new.clusters.ids) <- levels(run1)
run1 <- RenameIdents(run1, new.clusters.ids)
```

```{r pre_cluster_anno_vis, fig.height=6, fig.width=10}

DimPlot(run1, reduction = 'umap', label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
```

```{r}

plot <-  (DimPlot(run1, reduction = 'umap', label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3))))

ggsave(filename = "../Output/images/example.jpg", height = 6, width = 10, plot = plot, quality = 50)
```
