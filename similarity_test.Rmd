---
title: "Similarity test of SC Prostate Data"
author: "José Manuel Gómez Silva"
date: "2024-02-08"
output: html_document
---

```{r setup, include=FALSE}

all_times <- list() # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))

knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE,
  echo = TRUE,
  engine.opts = list(bash = "-l")
)
```

```{r libraries}

library(Seurat)
library(ggpubr)
library(ggplot2)
```

# Testing similarity between cell groups.

To implement the similarity score method, we would calculate a score that quantifies the resemblance between the gene expression profile of each AT and NAT cell and the average profile of T cells. A common similarity measure is the cosine similarity. Here's a step-by-step guide on how we will to implement this using R and the Seurat package:

1.  Calculus of the Average Expression Profile for T group: First, we need to calculate the average expression profile for the T group. This will serve as the reference profile to which we will compare the AT cells.
2.  Normalization and data scaling: We will ensure that our data is normalized and scaled appropriately to allow for meaningful comparisons between cells.
3.  Calculus of the Similarity Scores: For each AT cell, calculate the similarity score with the average T cell profile using cosine similarity.
4.  Interpretation of the Scores: Higher similarity scores indicate a closer resemblance to the T group profile. We will set a threshold to determine which cells are considered similar to T cells.

We will follow this steps using 3 different data sources: the normalized counts, the same data from the top variable genes, and the lgg2FC from the top differentially expressed genes.

The cosine method creates a vector with the expression values of the cells, represents it on a inner product space, calculates the cosine of the angle between the vectors and takes it as a measure of their similarity.

```{r load_processed_data}

SCP_data <- readRDS(file = "~/Documents/SC_Prostate/Data/SC_Prostate_processed.rds")
```

For this purpose, we will create a function that calculates the cosine similarity of two vectors.

The formula for the cosine similarity calculation based on the Euclidean dot product of two vectors is:

![](images/clipboard-436058134.png){width="675"}

The implementation for this in R would be:

```{r cosine_func}

# Function to calculate cosine similarity.
CosineSimilarity <- function(A, B) {
  sum(A * B) / (sqrt(sum(A^2)) * sqrt(sum(B^2)))
}
```

Another method is the Jaccard Index, whic measures similarity between finite sample sets, and is defined as the size of the intersection divided by the size of the union of the sample sets:

![](images/eaef5aa86949f49e7dc6b9c8c3dd8b233332c9e7.svg){width="672"}

This method is specially usefull to compare the list of differentiallly expressed genes of two different datasets compared againts a common control. Here is the R implementation:

```{r JaccardSimilarity}

JaccardSimilarity <- function(x, y) {
  
  # Step 1: Create gene sets
  x_names <- names(x)
  y_names <- names(y)
  unique_names <- union(x_names, y_names)
  
  # Step 2: Determine direction of differential expression
  x_up <- names(x[x > 0])
  x_down <- names(x[x < 0])
  y_up <- names(y[y > 0])
  y_down <- names(y[y < 0])
  
  # Step 4: Calculate similarity score
  num_overlap_up <- length(intersect(x_up, y_up))
  num_overlap_down <- length(intersect(x_down, y_down))
  num_unique_names <- length(unique_names)
  
  # Adjust the score based on direction
  similarity_score <- (num_overlap_up + num_overlap_down) / num_unique_names
  
  return(similarity_score)

}
```

We also add the possibility to perform Pearson, Kendall or Spearman correlation tests with the method argument (default is cosine similarity):

```{r SimilarityScore}

SimilarityScore <- function(x, y, method = "cosine") {
  
  method = tolower(method)
  
  if (method == "cosine") {
    CosineSimilarity(x, y)
    } else if (method == "jaccard") {
    JaccardSimilarity(x, y)
    } else {
      cor(x, y, method = method)
    }
}
```

We then create a function to access the data in a SeuratObject and calculate the similarity score in three ways, per-cell, per-sample or per-group.

This functions calculates the average expression vector for the specified reference group and compares a target group against it in a per-cell, per-sample or per-group approach.

The function returns a named vector with the similarity score for each cell/sample or the whole group for the specified target. If the selected mode is "all" it would get the similarity score for all the cells in the dataset.

We added additional function to also test this using the data only from the top variable genes and the differentially expressed genes of from the two groups

```{r SCDiffExp}

SCDiffExp <- function(SeuratObject, mode, test, control, fc.threshold = 1.5, p.threshold = 0.05) {
  # NOTE: DE = Differential Expression
  
  # SCDiffExp automatically performs a DE analysis over a SeuratObject to the indicated cells sets. IMPORTANT: It requieres normalized data by SCTransform. Retuns the FC of each significant DE gene in a named vector where the vector names are the gene names.
  
  # SeuratObject: The Seurat data.
  # mode = sample or group approach.
  # test = The tested set of cells for the DE analysis.
  # control = The group of cells which the test set is compared against.
  # fc.threshold = FC threshold to filter the DE analysis output.
  # p.threshold = p-ajd threshold to filter the DE analysis output.
  
  # Checks if Seurat if install with require and if not, tries to install it. If installation fails, the function is stopped.
  if (!require("Seurat", character.only = TRUE)) {
    cat("Package Seurat not found, trying to install...\n")
    install.packages("Seurat")
    if (!require("Seurat", character.only = TRUE)) {
      stop("Package Seurat not found")
    }
  }
  
  # Controls cases. Be aware this is only applicable for the current project, if function is reused, we recommend to skip this control
  mode = tolower(mode)
  control = toupper(control)
  
  # Avoids error in FindMarkers after using two merged SeuratOjects which comes from the same SeuratObject originally.
  recorrect_umi <- TRUE

  if (mode == "sample") {
    group.by <- "Sample_Name"
    recorrect_umi <- FALSE
    } else if (mode == "group") {
      group.by <- "Sample_Group"
    } else {
      cat("DE analysis can only be executed by sample or by group\n")
      return(NULL)
    }
  
  # Set FC threshold.
  FC <- log2(fc.threshold)
  
  # Calls Seurat's FindMarkers. Test vs Control.
  DE <- FindMarkers(SeuratObject, ident.1 = test, ident.2 = control, group.by = group.by, recorrect_umi = recorrect_umi, assay = "SCT")
  
  # Filter relevant genes.
  DE <- subset(DE, DE$avg_log2FC > FC & DE$p_val_adj < p.threshold |
                 DE$avg_log2FC < -FC & DE$p_val_adj < p.threshold, select = "avg_log2FC")
  
  # Returns a named vector with the FC values and gene names as vector's names.
  DE <- setNames(DE$avg_log2FC, row.names(DE))
  
  return(DE)
  
}
```

```{r SCDiffExp.sample}

SCDiffExp.sample <- function(SeuratObject, mode = "sample", test, control, fc.threshold = 1.5, p.threshold = 0.05) {
  # NOTE: DE = Differential Expression
  
  # This function is an interface for SCDiffExp to easily perform DE nalysis over all the samples contained in a certain group against the whole expression of a control group. It outputs a list of named vectors, each one containin the DE profile of a sample. The list element's names are the genes names.
  
  # SeuratObject: The Seurat data.
  # mode = sample approach only.
  # test = The tested set of cells for the DE analysis.
  # control = The group of cells which the test set is compared against.
  # fc.threshold = FC threshold to filter the DE analysis output.
  # p.threshold = p-ajd threshold to filter the DE analysis output.
  
  # Checks if Seurat if install with require and if not, tries to install it. If installation fails, the function is stopped.
  if (!require("Seurat", character.only = TRUE)) {
    cat("Package Seurat not found, trying to install...\n")
    install.packages("Seurat")
    if (!require("Seurat", character.only = TRUE)) {
      stop("Package Seurat not found")
    }
  }
  
  # Controls cases. Be aware this is only applicable for the current project, if function is reused, we recommend to skip this control
  mode = tolower(mode)
  test = toupper(test)
  control = toupper(control)
  
  if (mode != "sample") {
     cat("This function only executes DE by sample\n")
     return(NULL)
  }
  
  # Step 1: subset the control group. For convenience, the sample group is added as the sample name for all cells. That way all the control group will be treated as a single sample in further steps.
  ctrl_group <- subset(SeuratObject, Sample_Group == control)
  ctrl_group$Sample_Name <- ctrl_group$Sample_Group
  
  # Step 2: Subset the test group.
  test_cells <- subset(SeuratObject, Sample_Group == test)
  DE_data <- merge(ctrl_group, test_cells)
  
  # Storage each sample's DE profile as a vector and outputs all sample's vector as a list.   
  DE <- list()
  # Loop over each unique sample name to calculate similarity scores. The control will always be same, whereas it iterates over the samples of the test group.
  for (sample in unique(DE_data$Sample_Name)) {
    # Avoids testing the control against itself.
    if (sample != control) {
    # Each vector is named after its sample.
    DE[[sample]] <- SCDiffExp(SeuratObject = DE_data, mode = mode, test = sample, control = control, fc.threshold = fc.threshold, p.threshold = p.threshold)
    }
  }
  
  return(DE)
}

```

```{r SimilarityScoreDiffExp}

SimilarityScoreDiffExp <- function(SeuratObject, mode, target, reference, control, fc.threshold = 1.5, p.threshold = 0.05, method = "jaccard") {
  # NOTE: DE = Differential Expression.
  
  # SimilarityScoreDiffExp calculates the similarities scores based on the obtained differential expression profile of the samples. It can perfomed this analysis on a group-wise or sample-wise approach:
  # - Group-wise: Target group vs reference group.
  # - Sample-wise: Each sample of the target group vs reference group. It outputs a vector with the sample names as the vector's names and the similarity score as values.
  
  # SeuratObject: The Seurat data.
  # mode = sample or group approach.
  # target = This is the set of cells that we want to know if it is similar to another "reference" set based on their DE profile agains a "control" set.
  # reference: The set of cells we want to use for the comparison
  # control = The set of cells which reference and control groups are compared against to obtain their DE profiles.
  # fc.threshold = FC threshold to filter the DE analysis output.
  # p.threshold = p-ajd threshold to filter the DE analysis output.
  
  # Controls cases. Be aware this is only applicable for the current project, if function is reused, we recommend to skip this control
  mode = tolower(mode)
  method = tolower(method)
  target = toupper(target)
  reference = toupper(reference)
  control = toupper(control)
  
  # Only Jaccard Index and Cosine Similarity are compatible with DE approach.
  if (method != "jaccard" & method != "cosine") {
    cat("Only Jaccard Index and Cosine Similarity methods available for DiffExp-based similarity\n")
    return(NULL)
  }
    
    if (mode == "sample") {
      
      # Get the list of all the sample's DE profiles.
      DE_target <- SCDiffExp.sample(SeuratObject = SeuratObject, mode = mode, test = target, control = control, fc.threshold = fc.threshold, p.threshold = p.threshold)
      
      # Obtain the reference group's DE profile.
      DE_reference <- SCDiffExp(SeuratObject = SeuratObject, mode = "group", test = reference, control = control, fc.threshold = fc.threshold, p.threshold = p.threshold)
      
      # Storage the similarity score of all samples in a list.
      similarity_score <- list()
      for (sample in unique(names(DE_target))) {
        similarity_score[sample] <- SimilarityScore(DE_target[[sample]], DE_reference, method = method)
      }
      similarity_score <- unlist(similarity_score)
      
    } else if (mode == "group") {
      
      DE_target <- SCDiffExp(SeuratObject = SeuratObject, mode = mode, test = target, control = control, fc.threshold = fc.threshold, p.threshold = p.threshold)
    
    DE_reference <- SCDiffExp(SeuratObject = SeuratObject, mode = mode, test = reference, control = control, fc.threshold = fc.threshold, p.threshold = p.threshold)
      
    similarity_score <- SimilarityScore(DE_target, DE_reference, method = method)
      
    } else {
      
      cat("DE-based similarity score calculation can only be executed by sample or by group\n")
      similarity_score <- NULL
    }
    
  return(similarity_score)
}
```

```{r SCsimilarity}

SCsimilarity <- function(
    SeuratObject, mode, target, reference, control = NULL, use.top.genes = FALSE, n.top.genes = 50,  use.diffexp = FALSE, method = "cosine", fc.threshold = 1.5, p.threshold = 0.05
    ) {
  
  mode = tolower(mode)
  method = tolower(method)
  target = toupper(target)
  reference = toupper(reference)
  control = toupper(control)
  
  # Calculate average expression of the reference group.
  ref_group <- subset(SeuratObject, Sample_Group == reference)
  ref_group_avg <- AverageExpression(ref_group, assay = "SCT", slot = "scale.data")
  ref_group_avg <- ref_group_avg$SCT[,1]
  
  # Get target cells.
  target_cells <- subset(SeuratObject, Sample_Group == target)
  
  if (use.diffexp) {
    
    if (is.null(control)) {
      cat("Please, indicate the control group for the DE analysis\n")
      return(NULL)
    }
    
    use.top.genes = FALSE
    
    similarity_scores <- SimilarityScoreDiffExp(SeuratObject, mode, target, reference, control, method, fc.threshold, p.threshold)
    return(similarity_scores)
  }
  
  
  if (use.top.genes) {
    # Get top genes.
    top_genes <- head(VariableFeatures(SeuratObject), n.top.genes)
    # Filter reference group genes.
    ref_group_avg <- ref_group_avg[top_genes]
  }
  
  
  if (mode == "cell") {
    # Extract the scaled data for similarity calculations.
    data_matrix <- GetAssayData(target_cells, assay = "SCT", slot = "scale.data")
    if (use.top.genes) {data_matrix <- data_matrix[top_genes,]}

  # Calculate similarity scores for all cells.
    similarity_scores <- apply(data_matrix, 2, function(cell_expression) {
      SimilarityScore(cell_expression, ref_group_avg, method = method)
      })
  }
  
  
  if (mode == "sample") {
    similarity_scores = list()
    
    # Loop over each unique sample name to calculate similarity scores
    for (sample in unique(target_cells$Sample_Name)) {
      # Subset Seurat object for cells from the current sample
      sample_cells <- subset(target_cells, Sample_Name == sample)
      
      # Aggregate the expression data for the current sample
      sample_avg_expression <- AverageExpression(sample_cells, assay = "SCT", slot = "scale.data")
      sample_avg_expression <- sample_avg_expression$SCT[,1]
      if (use.top.genes) {sample_avg_expression <- sample_avg_expression[top_genes]}

      # Calculate cosine similarity with the reference group average expression
     similarity_scores[sample] <- SimilarityScore(sample_avg_expression, ref_group_avg, method = method)
    }
    
    similarity_scores <- unlist(similarity_scores)
  }
  
  
  if (mode == "group") {
    # Aggregate the expression data for the current sample
    target_group_avg <- AverageExpression(target_cells, assay = "SCT", slot = "scale.data")
    target_group_avg <- target_group_avg$SCT[,1]
    if (use.top.genes) {target_group_avg <- target_group_avg[top_genes]}
    
    similarity_scores <- SimilarityScore(target_group_avg, ref_group_avg, method = method)
  }
    
  
  if (mode == "all") {
    # Extract the scaled data for similarity calculations.
    data_matrix <- GetAssayData(SeuratObject, assay = "SCT", slot = "scale.data")
    if (use.top.genes) {data_matrix <- data_matrix[top_genes,]}
  
    # Calculate similarity scores for all cells.
      similarity_scores <- apply(data_matrix, 2, function(cell_expression) {
        SimilarityScore(cell_expression, ref_group_avg, method = method)
        })
  }
  
    
  return(similarity_scores)
}
```

## A. Cosine similarity calculation per cell.

We consider a threshold of an 80% similarity enough for a dataset to be considered tumoral.

Using this approach no cell meets the requirements.

```{r filter_cells}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "cell", target = "AT", reference = "T")

# We set a threshold of similarity.
threshold <- 0.8
similar_cells_AT <- names(similarity_scores_AT[similarity_scores_AT > threshold])

length(similar_cells_AT)
```

## B. Cosine similarity calculation per sample.

When applied to the average of all samples, all AT samples are classified as tumoral.

```{r filter_samples}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "sample", target = "AT", reference = "T")

# We set a threshold of similarity.
threshold <- 0.8
similar_groups_AT <- names(similarity_scores_AT[similarity_scores_AT > threshold])

length(similar_groups_AT)
```

## C. Cosine similarity calculation per group.

When we use the average of the whole group, everything looks right, till we also check the similarity with the N group...

```{r filter_groups}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "T")

similarity_scores_AT
```

```{r N_group}

test_N <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "N")

test_N
```

Seems that heterogeneity of the biopsy itself creates too much noise for this method to be applicable. Actually, when we compare the T group vs the N group:

```{r T_vs_N}

TvsN <- SCsimilarity(SCP_data, mode = "group", target = "T", reference = "N")

TvsN
```

Taking into account that we are studying patients at low-risk-stages and reduced aggressiveness of the tumor, and the intrinsic heterogeneity of the samples, the use of cosine similarity is not an appropriate method for sample comparison.

Pearson correlation provides similar results:

```{r pearson_test}

TvsN <- SCsimilarity(SCP_data, mode = "group", target = "T", reference = "N", method = "pearson")
TvsN
```

We plot the N vs T group average expression and estimate its correlation (Pearson) as an example.

```{r pearson_plot, fig.height=6, fig.width=10}

# Calculate average expression of the reference group.
ref_group <- subset(SCP_data, Sample_Group == "N")
ref_group_avg <- AverageExpression(ref_group, assay = "SCT", slot = "scale.data")
  
# Calculate average expression of the target group.
target_cells <- subset(SCP_data, Sample_Group == "T")
target_group_avg <- AverageExpression(target_cells, assay = "SCT", slot = "scale.data")
  
data <- data.frame(ref_group_avg$SCT[,1], target_group_avg$SCT[,1])

ggscatter(data, x = "ref_group_avg.SCT...1.", y = "target_group_avg.SCT...1.",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "N group average expression", ylab = "T group average expression")
```

As we can see, both tumoral and healthy groups' expression profile pretty much coincides, so taking the whole transcriptome for comparison would not be an effective ways to asses sample similarity.

Now we will try a method based on the expression signature given by the top 50 genes from the dataset.

# Comparison with top variable genes.

In the following figure we label the top 50 most variable genes among the dataset. We will use them to filter the gene expression profile.

```{r var_features, fig.height=6, fig.width=10}

# Genes with differencial expression in different cells are good candidates to be biomarkers.
# Identify the 50 most highly variable genes (this data is already stored in the SeuratObject)
top_genes <- head(VariableFeatures(SCP_data), 50)

# plot variable features with  labels
plot1 <- VariableFeaturePlot(SCP_data)
plot1 <- LabelPoints(plot = plot1, points = top_genes, repel = TRUE)
plot1
```

Unfortunately, after repeating the same tests using exclusively the top variable genes, results are pretty much the same.

```{r filter_top_genes}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "T", use.top.genes = TRUE)

similarity_scores_AT
```

```{r N_group_top_genes}

test_N <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "N", use.top.genes = TRUE)

test_N
```

```{r pearson_plot_top_genes, fig.height=6, fig.width=10}

# Calculate average expression of the reference group.
ref_group <- subset(SCP_data, Sample_Group == "N")
ref_group_avg <- AverageExpression(ref_group, assay = "SCT", slot = "scale.data")
ref_group_avg <- ref_group_avg$SCT[,1][top_genes]
  
# Calculate average expression of the target group.
target_cells <- subset(SCP_data, Sample_Group == "T")
target_group_avg <- AverageExpression(target_cells, assay = "SCT", slot = "scale.data")
target_group_avg <- target_group_avg$SCT[,1][top_genes]
  
data <- data.frame(ref_group_avg, target_group_avg)

ggscatter(data, x = "ref_group_avg", y = "target_group_avg",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "N top genes average expression", ylab = "T top genes average expression")
```

We will now proceed to apply a different methodology in which we will use the differentially expressed gene on each sample group to make the comparison.

# Comparison using deferentially expressed genes.

```{r}

SCsimilarity(SCP_data, mode = "sample", target = "AT", reference = "T", use.diffexp = FALSE, method = "cosine")

```

```{r}

FC <- log2(1.5)

DE_T <- FindMarkers(SCP_data, ident.1 = "T", ident.2 = "N", group.by = "Sample_Group")
DE_T <- subset(DE_T, DE_T$avg_log2FC > FC & DE_T$p_val_adj < 0.05 | DE_T$avg_log2FC < -FC & DE_T$p_val_adj < 0.05, select = "avg_log2FC")
DE_T <- setNames(DE_T$avg_log2FC, row.names(DE_T))
```

```{r}

DE_AT <- FindMarkers(SCP_data, ident.1 = "AT", ident.2 = "N", group.by = "Sample_Group")
DE_AT <- subset(DE_AT, DE_AT$avg_log2FC > FC & DE_AT$p_val_adj < 0.05 | DE_AT$avg_log2FC < -FC & DE_AT$p_val_adj < 0.05, select = "avg_log2FC")
DE_AT <- setNames(DE_AT$avg_log2FC, row.names(DE_AT))
```

```{r}

SimilariyScoreDiffExp(SCP_data, mode = "group", target = "AT", reference = "T", control = "N")
```
