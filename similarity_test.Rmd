---
title: "Similarity test of SC Prostate Data"
author: "José Manuel Gómez Silva"
date: "2024-02-08"
output: html_document
---

```{r setup, include=FALSE}

all_times <- list() # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))

knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE,
  echo = TRUE,
  engine.opts = list(bash = "-l")
)
```

```{r libraries}

library(Seurat)
library(ggpubr)
library(ggplot2)
```

# Testing similarity between cell groups.

To implement the similarity score method, we would calculate a score that quantifies the resemblance between the gene expression profile of each AT and NAT cell and the average profile of T cells. A common similarity measure is the cosine similarity. Here's a step-by-step guide on how we will to implement this using R and the Seurat package:

1.  Calculus of the Average Expression Profile for T group: First, we need to calculate the average expression profile for the T group. This will serve as the reference profile to which we will compare the AT cells.
2.  Normalization and data scaling: We will ensure that our data is normalized and scaled appropriately to allow for meaningful comparisons between cells.
3.  Calculus of the Similarity Scores: For each AT cell, calculate the similarity score with the average T cell profile using cosine similarity.
4.  Interpretation of the Scores: Higher similarity scores indicate a closer resemblance to the T group profile. We will set a threshold to determine which cells are considered similar to T cells.

The cosine method creates a vector with the expression values of the cells, represents it on a inner product space, calculates the cosine of the angle between the vectors and takes it as a measure of their similarity.

```{r load_processed_data}

SCP_data <- readRDS(file = "~/Documents/SC_Prostate/Data/SC_Prostate_processed.rds")
```

For this purpose, we will create a function that calculates the cosine similarity of two vectors.

The formula for the cosine similarity calculation based on the Euclidean dot product of two vectors is:

![](images/clipboard-436058134.png)

The implementation for this in R would be:

```{r cosine_func}

# Function to calculate cosine similarity.
CosineSimilarity <- function(A, B) {
  sum(A * B) / (sqrt(sum(A^2)) * sqrt(sum(B^2)))
}
```

We also add the possibility to perform Pearson, Kendall or Spearman correlation tests with the method argument (default is cosine similarity):

```{r}

SimilarityScore <- function(x, y, method = "cosine") {
  if (method == "cosine") {
    CosineSimilarity(x, y)
    } else {
      cor(x, y, method = method)
    }
}
```

We then create a function to access the data in a SeuratObject and calculate the similarity score in three ways, per-cell, per-sample or per-group.

This functions calculates the average expression vector for the specified reference group and compares a target group against it in a per-cell, per-sample or per-group approach.

The function returns a named vector with the similarity score for each cell/sample or the whole group for the specified target. If the selected mode is "all" it would get the similarity score for all the cells in the dataset.

```{r SCsimilarity}

SCsimilarity <- function(
    SeuratObject, mode, target, reference, use.top.genes = FALSE, n.top.genes = 50,  method = "cosine"
    ) {
  
  mode = tolower(mode)
  target = toupper(target)
  method = tolower(method)
  
  # Calculate average expression of the reference group.
  ref_group <- subset(SeuratObject, Sample_Group == reference)
  ref_group_avg <- AverageExpression(ref_group, assay = "SCT", slot = "scale.data")
  ref_group_avg <- ref_group_avg$SCT[,1]
  
  # Get target cells.
  target_cells <- subset(SeuratObject, Sample_Group == target)
  
  if (use.top.genes) {
  # Get top genes.
  top_genes <- head(VariableFeatures(SeuratObject), n.top.genes)
  # Filter reference group genes.
  ref_group_avg <- ref_group_avg[top_genes]
  }

  
  if (mode == "cell") {
    # Extract the scaled data for similarity calculations.
    data_matrix <- GetAssayData(target_cells, assay = "SCT", slot = "scale.data")
    if (use.top.genes) {data_matrix <- data_matrix[top_genes,]}

  # Calculate similarity scores for all cells.
    similarity_scores <- apply(data_matrix, 2, function(cell_expression) {
      SimilarityScore(cell_expression, ref_group_avg, method = method)
      })
  }
  
  
  if (mode == "sample") {
    similarity_scores = list()
    
    # Loop over each unique sample name to calculate similarity scores
    for (sample in unique(target_cells$Sample_Name)) {
      # Subset Seurat object for cells from the current sample
      sample_cells <- subset(target_cells, Sample_Name == sample)
      
      # Aggregate the expression data for the current sample
      sample_avg_expression <- AverageExpression(sample_cells, assay = "SCT", slot = "scale.data")
      sample_avg_expression <- sample_avg_expression$SCT[,1]
      if (use.top.genes) {sample_avg_expression <- sample_avg_expression[top_genes]}

      # Calculate cosine similarity with the reference group average expression
     similarity_scores[sample] <- SimilarityScore(sample_avg_expression, ref_group_avg, method = method)
    }
    
    similarity_scores <- unlist(similarity_scores)
  }
  
  
  if (mode == "group") {
    # Aggregate the expression data for the current sample
    target_group_avg <- AverageExpression(target_cells, assay = "SCT", slot = "scale.data")
    target_group_avg <- target_group_avg$SCT[,1]
    if (use.top.genes) {target_group_avg <- target_group_avg[top_genes]}
    
    similarity_scores <- SimilarityScore(target_group_avg, ref_group_avg, method = method)
  }
    
  
  if (mode == "all") {
    # Extract the scaled data for similarity calculations.
    data_matrix <- GetAssayData(SeuratObject, assay = "SCT", slot = "scale.data")
    if (use.top.genes) {data_matrix <- data_matrix[top_genes,]}
  
    # Calculate similarity scores for all cells.
      similarity_scores <- apply(data_matrix, 2, function(cell_expression) {
        SimilarityScore(cell_expression, ref_group_avg, method = method)
        })
  }
  
    
  return(similarity_scores)
}
```

## A. Cosine similarity calculation per cell.

We consider a threshold of an 80% similarity enough for a dataset to be considered tumoral.

Using this approach no cell meets the requirements.

```{r filter_cells}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "cell", target = "AT", reference = "T")

# We set a threshold of similarity.
threshold <- 0.8
similar_cells_AT <- names(similarity_scores_AT[similarity_scores_AT > threshold])

length(similar_cells_AT)
```

## B. Cosine similarity calculation per sample.

When applied to the average of all samples, all AT samples are classified as tumoral.

```{r filter_samples}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "sample", target = "AT", reference = "T")

# We set a threshold of similarity.
threshold <- 0.8
similar_groups_AT <- names(similarity_scores_AT[similarity_scores_AT > threshold])

length(similar_groups_AT)
```

## C. Cosine similarity calculation per group.

When we use the average of the whole group, everything looks right, till we also check the similarity with the N group...

```{r filter_groups}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "T")

similarity_scores_AT
```

```{r N_group}

test_N <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "N")

test_N
```

Seems that heterogeneity of the biopsy itself creates too much noise for this method to be applicable. Actually, when we compare the T group vs the N group:

```{r T_vs_N}

TvsN <- SCsimilarity(SCP_data, mode = "group", target = "T", reference = "N")

TvsN
```

Taking into account that we are studying patients at low-risk-stages and reduced aggressiveness of the tumor, and the intrinsic heterogeneity of the samples, the use of cosine similarity is not an appropriate method for sample comparison.

Pearson correlation provides similar results:

```{r pearson_test}

TvsN <- SCsimilarity(SCP_data, mode = "group", target = "T", reference = "N", method = "pearson")
TvsN
```

We plot the N vs T group average expression and estimate its correlation (Pearson) as an example.

```{r pearson_plot, fig.height=6, fig.width=10}

# Calculate average expression of the reference group.
ref_group <- subset(SCP_data, Sample_Group == "N")
ref_group_avg <- AverageExpression(ref_group, assay = "SCT", slot = "scale.data")
  
# Calculate average expression of the target group.
target_cells <- subset(SCP_data, Sample_Group == "T")
target_group_avg <- AverageExpression(target_cells, assay = "SCT", slot = "scale.data")
  
data <- data.frame(ref_group_avg$SCT[,1], target_group_avg$SCT[,1])

ggscatter(data, x = "ref_group_avg.SCT...1.", y = "target_group_avg.SCT...1.",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "N group average expression", ylab = "T group average expression")
```

As we can see, both tumoral and healthy groups' expression profile pretty much coincides, so taking the whole transcriptome for comparison would not be an effective ways to asses sample similarity.

Now we will try a method based on the expression signature given by the top 50 genes from the dataset.

# Comparison with top variable genes.

In the following figure we label the top 50 most variable genes among the dataset. We will use them to filter the

```{r var_features, fig.height=6, fig.width=10}

# Genes with differencial expression in different cells are good candidates to be biomarkers.
# Identify the 50 most highly variable genes (this data is already stored in the SeuratObject)
top_genes <- head(VariableFeatures(SCP_data), 50)

# plot variable features with  labels
plot1 <- VariableFeaturePlot(SCP_data)
plot1 <- LabelPoints(plot = plot1, points = top_genes, repel = TRUE)
plot1
```

Unfortunately, after repeating the same tests using exclusively the top variable genes, results are pretty much the same.

```{r filter_top_genes}

similarity_scores_AT <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "T", use.top.genes = TRUE)

similarity_scores_AT
```

```{r N_group_top_genes}

test_N <- SCsimilarity(SCP_data, mode = "group", target = "AT", reference = "N", use.top.genes = TRUE)

test_N
```

```{r pearson_plot_top_genes, fig.height=6, fig.width=10}

# Calculate average expression of the reference group.
ref_group <- subset(SCP_data, Sample_Group == "N")
ref_group_avg <- AverageExpression(ref_group, assay = "SCT", slot = "scale.data")
ref_group_avg <- ref_group_avg$SCT[,1][top_genes]
  
# Calculate average expression of the target group.
target_cells <- subset(SCP_data, Sample_Group == "T")
target_group_avg <- AverageExpression(target_cells, assay = "SCT", slot = "scale.data")
target_group_avg <- target_group_avg$SCT[,1][top_genes]
  
data <- data.frame(ref_group_avg, target_group_avg)

ggscatter(data, x = "ref_group_avg", y = "target_group_avg",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "N top genes average expression", ylab = "T top genes average expression")
```

We will now proceed to apply a different methodology in which we will use the diferentially expressed gene on each sample group to make the comparison.

# Comparison using deferentially expressed genes.

```{r}

FC <- log2(1.5)

DE_T <- FindMarkers(SCP_data, ident.1 = "T", ident.2 = "N", group.by = "Sample_Group")
DE_T <- subset(DE_T, DE_T$avg_log2FC > FC & DE_T$p_val_adj < 0.05 | DE_T$avg_log2FC < -FC & DE_T$p_val_adj < 0.05, select = "avg_log2FC")
DE_T <- setNames(DE_T$avg_log2FC, row.names(DE_T))
```

```{r}

FC <- log2(1.5)

DE_AT <- FindMarkers(SCP_data, ident.1 = "AT", ident.2 = "N", group.by = "Sample_Group")
DE_AT <- subset(DE_AT, DE_AT$avg_log2FC > FC & DE_AT$p_val_adj < 0.05 | DE_AT$avg_log2FC < -FC & DE_AT$p_val_adj < 0.05, select = "avg_log2FC")
DE_AT <- setNames(DE_AT$avg_log2FC, row.names(DE_AT))
```

```{r}

JaccardSimilarity <- function(x, y) {
  # Compute Jaccard similarity coefficient
  similarity_score <- length(intersect(x, y)) / length(union(x, y))
  
  return(similarity_score)
}
```

```{r}

intersect(DE_T, DE_AT)

# RESUMEN: JACCARD NO, BUSCAR TEST DE SIMILARIDAD COMPATIBLE.
```
