# Standard normalization.
SCP_data <- NormalizeData(SCP_data)
SCP_data <- FindVariableFeatures(SCP_data, nfeatures = 3000)
SCP_data <- ScaleData(SCP_data)
# Launch sct transform and run PCA.
SCP_data <- SCTransform(SCP_data, vst.flavor = "v2", vars.to.regress = "percent.mt")
SCP_data <- RunPCA(SCP_data, assay = "SCT")
# Integration.
SCP_data <- IntegrateLayers(
object = SCP_data, method = CCAIntegration,
normalization.method = "SCT",
verbose = FALSE
)
Idents(SCP_data) <- "orig.ident"
DimPlot(SCP_data, reduction = "pca")
ElbowPlot(SCP_data, ndims = 50, reduction = "pca") # choose 30
DimHeatmap(SCP_data, dims = 1:30, balanced = TRUE, reduction = "pca")
VizDimLoadings(SCP_data, dims = 1:30, reduction = "pca")
# SCP_data <- FindVariableFeatures(SCP_data, selection.method = "vst", nfeatures = 3000, assay = "SCT")
# Genes with differential expression in different cells are good candidates to be biomarkers.
# Identify the 20 most highly variable genes
top <- head(VariableFeatures(SCP_data, assay = "SCT",layer = run), 20)
# Resolution fine-tuned in a separate Rmd.
SCP_data <- FindNeighbors(SCP_data, dims = 1:30, reduction = "harmony")
SCP_data <- FindClusters(SCP_data, resolution = 0.8, ) # Default resolution = 0.8
SCP_data <- RunUMAP(SCP_data, dims = 1:30, reduction = "harmony")
p1 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p2 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4, group.by = "Sample_Name") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p3 <- DimPlot(SCP_data, reduction = "umap", label = FALSE, repel = TRUE, label.size = 4, group.by = "orig.ident") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p1 + p2 + p3
clusters <- levels(SCP_data$seurat_clusters)
df <- data.frame()
for(i in 1:length(clusters)){
cur_df <- as.data.frame(SCP_data@meta.data %>% subset(seurat_clusters == clusters[i]) %>% .$orig.ident %>% table() /
table(SCP_data$orig.ident))
cur_df$Freq <- cur_df$Freq * 1/(sum(cur_df$Freq))
cur_df$cluster <- clusters[i]
df <- rbind(df, cur_df)
}
RunFreq.Int <- ggplot(df, aes(y=Freq, x=cluster, fill=.)) +
geom_bar(stat='identity') +
scale_y_continuous(expand = c(0,0)) +
ylab('normalized proportion') +
theme(
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
axis.text.x = element_text(angle=45, hjust=1),
axis.title.x = element_blank(),
legend.title = element_blank(),
axis.line.y = element_blank(),
axis.line.x = element_blank()
)
RunFreq.Int
RunFreq.noInt + RunFreq.Int
# Visualize QC metrics as a violin plot
VlnPlot(SCP_data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) + NoLegend()
# Zoom in on nFeature_RNA violin plot.
VlnPlot(SCP_data, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()
# Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(SCP_data, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(SCP_data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + NoLegend() + plot2 + NoLegend()
# Using celldex and SingleR packages.
# Download reference data from celldex.
reference <- HumanPrimaryCellAtlasData()
# Join layers before conversion. SingleR uses the RNA assay.
merged.SCexp <- JoinLayers(SCP_data, assay = "RNA")
# Convert Seurat object into a SingleCellExperiment Object for SingleR input.
merged.SCexp <- as.SingleCellExperiment(merged.SCexp)
SingleR.annotation <- SingleR(test = merged.SCexp, ref = reference, assay.type.test = "logcounts", labels = reference$label.main, num.threads = detectCores())
SCP_data[["cell.labels"]] <- SingleR.annotation$labels
DimPlot(SCP_data, reduction = "umap", group.by = "cell.labels", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
# Obtaining a vector containing the cluster of each cell in order.
# Get the factor contained in the SeuratObject with all this information.
clusters <- SCP_data@meta.data[["seurat_clusters"]]
# The cluster information for each cell is contain as a factor which levels coincide with the total number of clusters found by FindClusters(). An approach to transform this factor into a character vector is the following:
# Obtain the list of clusters with levels(clusters). This outputs a character vector containing the levles of the factor. After that, we use the factor itself as an index to access the levels vector. When using a factor as an index, R does not use the labels itself (which in this case are string, so if used as indexes would cause an error), but the internal numeric index the factor contains. That way, for each cluster label associated with a cell in the factor, we access its numeric index and map it to the levels vectors (which coincides), thus obtaining each cell label as an unique character value. Each cell label is then storage as a character (the as.character is added as a control method since SingleR only admits strings as labels) in a vector. The vector contains the cluster label for each cell as a character value in the same order as each cell appears in the dataset, so the by-cluster annotation doesn't assign the cells to an incorrect cluster.
clusters <- as.character(levels(clusters)[clusters])
# reference <- HumanPrimaryCellAtlasData()
# merged.SCexp <- as.SingleCellExperiment(SCP_data)
# We input the cluster vector using the clusters parameter.
SingleR.annotation <- SingleR(test = merged.SCexp, ref = reference, assay.type.test = "logcounts", labels = reference$label.main, clusters = clusters, num.threads = detectCores())
SCP_data[["cluster.labels"]] <- SingleR.annotation$labels
# We composite the cluster name. That way when 2 clusters' names are the same Seurat doesn't merge the labels.
# Get clusters levels accessing the SeuratObject variable as a df and then accessing the df as a column.
cluster_number <- levels(SCP_data[["seurat_clusters"]][1, ])
# Get annotation labels.
cluster_annotation <- SingleR.annotation$labels
# Since cluster levels and labels are in the same order, we composite the new names using paste0 (sort of equivalent to fstrings in python).
new.clusters.ids <- paste0(cluster_number, "-", cluster_annotation)
# Add names to each value of the clusters id vector so Seurat can take it as a valid input for RenameIdents.
names(new.clusters.ids) <- levels(SCP_data)
SCP_data <- RenameIdents(SCP_data, new.clusters.ids)
SCP_data[["cell.cluster.labels"]] <- Idents(SCP_data)
DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
# Sumarize() performs an operation over a row of a dataframe, for example mean() or count n().
# Slots are dataframes, so it can be used by dplyr.
prop_cell_by_sample <- SCP_data@meta.data %>% group_by(Sample_Name, cell.cluster.labels) %>%
summarise(n = n()) %>% # For each cluster, group the cells from the same sample together and count them.
ungroup() %>% group_by(Sample_Name) %>%
mutate(freq = n / sum(n)) %>% # Group them now by sample, add up the total number of cells from that sample (regardless of the cluster they belong to). Then, divide each n value (number of cells of a sample in a certain cluster), obtaining which fraction of the total cells of that given type is present on each cluster.
left_join(SCP_data@meta.data %>% select(Sample_Name, Sample_Group) %>% unique()) # Add metadata info available for the data, select only the Sample_Name and Sample_Group fields and delete duplicates.
# Filter only the desired groups "N" and "T"
prop_cell_by_sample_filtered <- prop_cell_by_sample %>%
filter(Sample_Group %in% c("N", "T"))
# Extract data for Sample_Group "T" and other groups
group_T <- prop_cell_by_sample[prop_cell_by_sample$Sample_Group == "T", ]
group_N <- prop_cell_by_sample[prop_cell_by_sample$Sample_Group == "N", ]
# Perform t-test for each cluster
clusters <- levels(prop_cell_by_sample$cell.cluster.labels)
p_values <- numeric(length(clusters))
for (i in seq_along(clusters)) {
cluster_data_T <- group_T[group_T$cell.cluster.labels == clusters[i], "freq"]
cluster_data_N <- group_N[group_N$cell.cluster.labels == clusters[i], "freq"]
# Perform test
test_result <- wilcox.test(cluster_data_T$freq, cluster_data_N$freq)
# Store p-value
p_values[i] <- test_result$p.value
}
# Identify clusters with significant enrichment (e.g., p-value < 0.05)
enriched_clusters <- clusters[p_values < 0.05]
# Print or visualize the enriched clusters
print(enriched_clusters)
print(p_values)
# Plot only the desired groups
enriched_clusters <- ggboxplot(prop_cell_by_sample_filtered, x = "Sample_Group", y = "freq",
color = "Sample_Group",  palette = "jco",
add = "jitter") +
facet_wrap(~cell.cluster.labels, scales = "free", nrow = 6) +
theme(legend.position = "none") +
xlab("Sample Group") + ylab("Frequency") +
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5)
enriched_clusters
# By-cell method (uses integrated and SCTransformed data)
SCP_data <- PrepSCTFindMarkers(SCP_data)
cluster18.markers.cell <- FindMarkers(SCP_data, ident.1 = "T", ident.2 = "N", group.by = "Sample_Group", subset.ident = "18-T_cells", assay = "SCT", recorrect_umi = FALSE)
# Using pseudobulk.
bulk <- AggregateExpression(SCP_data, return.seurat = T, slot = "counts", assays = "RNA", group.by = c("seurat_clusters",
"Sample_Name", "Sample_Group"))
# We don't know why it adds a "g" after pseudobulking.
cluster18 <- subset(bulk, seurat_clusters == "g18")
# As we are using bulks instead of cells, we need to change the test to a more appropiate one.
cluster18.markers.bulk <- FindMarkers(cluster18, ident.1 = "T", ident.2 = "N", group.by = "Sample_Group", test.use = "DESeq2")
FC = log2(1.5) # Set FC threshold.
# Add a column to the data frame to specify if they are UP- or DOWN- regulated (log2fc respectively positive or negative).
cluster18.markers.cell$diffexpressed <- "NO"
# if FC > 1.5 (log2FC > ~0.6) and pvalue < 0.05, set as "UP".
cluster18.markers.cell$diffexpressed[cluster18.markers.cell$avg_log2FC > FC & cluster18.markers.cell$p_val < 0.05] <- "UP"
# if FC < 0.666 (invers 1/1.5 calculated as log2FC < ~-0.6) and pvalue < 0.05, set as "DOWN".
cluster18.markers.cell$diffexpressed[cluster18.markers.cell$avg_log2FC < -FC & cluster18.markers.cell$p_val < 0.05] <- "DOWN"
cluster18.markers.cell <- cluster18.markers.cell %>%
arrange(p_val) %>%
mutate(gene_symbol = rownames(.)) %>%
group_by(diffexpressed) %>%
mutate(delabel = if_else(diffexpressed %in% c("UP", "DOWN") & row_number() <= 10, gene_symbol, NA)) %>%
ungroup()
cell.DE <- ggplot(cluster18.markers.cell, aes(x = avg_log2FC, y = -log10(p_val), col = diffexpressed, label = delabel)) +
geom_vline(xintercept = c(-FC, FC), col = "grey", linetype = 'dashed') +
geom_hline(yintercept = -log10(0.05), col = "grey", linetype = 'dashed') +
geom_point(size = 2) +
scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable
labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
labs(color = NULL, #legend_title,
x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) +
theme_classic() +
scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
geom_text_repel(box.padding = 0.6, max.overlaps = Inf) # To show all labels
# Add a column to the data frame to specify if they are UP- or DOWN- regulated (log2fc respectively positive or negative).
cluster18.markers.bulk$diffexpressed <- "NO"
# if FC > 1.5 (log2FC > ~0.6) and pvalue < 0.05, set as "UP".
cluster18.markers.bulk$diffexpressed[cluster18.markers.bulk$avg_log2FC > FC & cluster18.markers.bulk$p_val < 0.05] <- "UP"
# if FC < 0.666 (invers 1/1.5 calculated as log2FC < ~-0.6) and pvalue < 0.05, set as "DOWN".
cluster18.markers.bulk$diffexpressed[cluster18.markers.bulk$avg_log2FC < -FC & cluster18.markers.bulk$p_val < 0.05] <- "DOWN"
cluster18.markers.bulk <- cluster18.markers.bulk %>%
arrange(p_val_adj) %>%
mutate(gene_symbol = rownames(.)) %>%
group_by(diffexpressed) %>%
mutate(delabel = if_else(diffexpressed %in% c("UP", "DOWN") & row_number() <= 10, gene_symbol, NA)) %>%
ungroup()
bulk.DE <- ggplot(cluster18.markers.bulk, aes(x = avg_log2FC, y = -log10(p_val), col = diffexpressed, label = delabel)) +
geom_vline(xintercept = c(-FC, FC), col = "grey", linetype = 'dashed') +
geom_hline(yintercept = -log10(0.05), col = "grey", linetype = 'dashed') +
geom_point(size = 2) +
scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable
labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
labs(color = NULL, #legend_title,
x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) +
theme_classic() +
scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
geom_text_repel(box.padding = 0.6, max.overlaps = Inf) # To show all labels
cell.DE + bulk.DE
sessionInfo()
RNGkind()
View(SCP_data)
all_times <- list() # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
now <- NULL
function(before, options) {
if (before) {
now <<- Sys.time()
} else {
res <- difftime(Sys.time(), now, units = "secs")
all_times[[options$label]] <<- res
}
}
}))
knitr::opts_chunk$set(
tidy = TRUE,
tidy.opts = list(width.cutoff = 95),
message = FALSE,
warning = FALSE,
time_it = TRUE,
error = TRUE,
echo = TRUE,
engine.opts = list(bash = "-l")
)
library(Seurat)
library(dplyr)
library(patchwork)
library(sctransform)
library(ggplot2)
library(ggpubr)
library(tidyr)
library(ggrepel)
library(celldex) # Cell annotation.
library(SingleR) # Cell annotation.
library(parallel) # detectCores()
library(future) # Allows parallelization in Seurat.
library(readODS) # Allows ods file import to add sample info
# Set up Seurat pararell computing.
options(parallelly.fork.enable = TRUE)
plan("multicore", workers = detectCores())
# Adjust memory allocation per process.
options(future.globals.maxSize = 2000 * 1024^2) # 2 GB per thread.
SCP_data <- readRDS(file = "~/Documents/SC_Prostate/Data/SC_Prostate_processed.rds")
p1 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p2 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4, group.by = "Sample_Name") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p3 <- DimPlot(SCP_data, reduction = "umap", label = FALSE, repel = TRUE, label.size = 4, group.by = "orig.ident") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p1 + p2 + p3
all_times <- list() # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
now <- NULL
function(before, options) {
if (before) {
now <<- Sys.time()
} else {
res <- difftime(Sys.time(), now, units = "secs")
all_times[[options$label]] <<- res
}
}
}))
knitr::opts_chunk$set(
tidy = TRUE,
tidy.opts = list(width.cutoff = 95),
message = FALSE,
warning = FALSE,
time_it = TRUE,
error = TRUE,
echo = TRUE,
engine.opts = list(bash = "-l")
)
library(Seurat)
library(dplyr)
library(patchwork)
library(sctransform)
library(ggplot2)
library(ggpubr)
library(tidyr)
library(ggrepel)
library(celldex) # Cell annotation.
library(SingleR) # Cell annotation.
library(parallel) # detectCores()
library(future) # Allows parallelization in Seurat.
library(readODS) # Allows ods file import to add sample info
# Set up Seurat pararell computing.
options(parallelly.fork.enable = TRUE)
plan("multicore", workers = detectCores())
# Adjust memory allocation per process.
options(future.globals.maxSize = 2000 * 1024^2) # 2 GB per thread.
SCP_data <- readRDS(file = "~/Documents/SC_Prostate/Data/SC_Prostate_processed.rds")
p1 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p2 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4, group.by = "Sample_Name") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p3 <- DimPlot(SCP_data, reduction = "umap", label = FALSE, repel = TRUE, label.size = 4, group.by = "orig.ident") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p1 + p2 + p3
clusters <- levels(SCP_data$seurat_clusters)
df <- data.frame()
for(i in 1:length(clusters)){
if (clusters[i] != 4 & clusters[i] != 14)  {
cur_df <- as.data.frame(SCP_data@meta.data %>% subset(seurat_clusters == clusters[i]) %>% .$orig.ident %>% table() /
table(SCP_data$orig.ident))
cur_df$Freq <- cur_df$Freq * 1/(sum(cur_df$Freq))
cur_df$cluster <- clusters[i]
df <- rbind(df, cur_df)
} else {
cur_df <- as.data.frame(SCP_data@meta.data %>% subset(seurat_clusters == clusters[i]) %>% .$orig.ident %>% table())
cur_df$Freq <- cur_df$Freq * 1/(sum(cur_df$Freq))
cur_df$cluster <- clusters[i]
df <- rbind(df, cur_df)
}
}
RunFreq.noInt <- ggplot(df, aes(y=Freq, x=cluster, fill=.)) +
geom_bar(stat='identity') +
scale_y_continuous(expand = c(0,0)) +
ylab('normalized proportion') +
theme(
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
axis.text.x = element_text(angle=45, hjust=1),
axis.title.x = element_blank(),
legend.title = element_blank(),
axis.line.y = element_blank(),
axis.line.x = element_blank()
)
RunFreq.noInt
Idents(SCP_data) <- "orig.ident"
DimPlot(SCP_data, reduction = "pca")
SCP_data <- readRDS(file = "~/Documents/SC_Prostate/Data/SC_Prostate_raw.rds")
# The split method splits the given slot according to the indicated information.
SCP_data[["RNA"]] <- split(SCP_data[["RNA"]], f = SCP_data$orig.ident)
# Standard normalization.
SCP_data <- NormalizeData(SCP_data)
SCP_data <- FindVariableFeatures(SCP_data, nfeatures = 3000)
SCP_data <- ScaleData(SCP_data)
# Launch sct transform and run PCA.
SCP_data <- SCTransform(SCP_data, vst.flavor = "v2", vars.to.regress = "percent.mt")
SCP_data <- RunPCA(SCP_data, assay = "SCT")
# Integration.
SCP_data <- IntegrateLayers(
object = SCP_data, method = CCAIntegration,
normalization.method = "SCT",
verbose = FALSE
)
Idents(SCP_data) <- "orig.ident"
DimPlot(SCP_data, reduction = "pca")
ElbowPlot(SCP_data, ndims = 50, reduction = "pca") # choose 30
DimHeatmap(SCP_data, dims = 1:30, balanced = TRUE, reduction = "pca")
VizDimLoadings(SCP_data, dims = 1:30, reduction = "pca")
# SCP_data <- FindVariableFeatures(SCP_data, selection.method = "vst", nfeatures = 3000, assay = "SCT")
# Genes with differential expression in different cells are good candidates to be biomarkers.
# Identify the 20 most highly variable genes
top <- head(VariableFeatures(SCP_data, assay = "SCT",layer = run), 20)
# Resolution fine-tuned in a separate Rmd.
SCP_data <- FindNeighbors(SCP_data, dims = 1:30, reduction = "integrated.dr")
SCP_data <- FindClusters(SCP_data, resolution = 0.8, ) # Default resolution = 0.8
SCP_data <- RunUMAP(SCP_data, dims = 1:30, reduction = "integrated.dr")
p1 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p2 <- DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4, group.by = "Sample_Name") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p3 <- DimPlot(SCP_data, reduction = "umap", label = FALSE, repel = TRUE, label.size = 4, group.by = "orig.ident") + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
p1 + p2 + p3
clusters <- levels(SCP_data$seurat_clusters)
df <- data.frame()
for(i in 1:length(clusters)){
cur_df <- as.data.frame(SCP_data@meta.data %>% subset(seurat_clusters == clusters[i]) %>% .$orig.ident %>% table() /
table(SCP_data$orig.ident))
cur_df$Freq <- cur_df$Freq * 1/(sum(cur_df$Freq))
cur_df$cluster <- clusters[i]
df <- rbind(df, cur_df)
}
RunFreq.Int <- ggplot(df, aes(y=Freq, x=cluster, fill=.)) +
geom_bar(stat='identity') +
scale_y_continuous(expand = c(0,0)) +
ylab('normalized proportion') +
theme(
panel.grid.major=element_blank(),
panel.grid.minor=element_blank(),
axis.text.x = element_text(angle=45, hjust=1),
axis.title.x = element_blank(),
legend.title = element_blank(),
axis.line.y = element_blank(),
axis.line.x = element_blank()
)
RunFreq.Int
RunFreq.noInt + RunFreq.Int
# Visualize QC metrics as a violin plot
VlnPlot(SCP_data, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) + NoLegend()
# Zoom in on nFeature_RNA violin plot.
VlnPlot(SCP_data, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()
# Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(SCP_data, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(SCP_data, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + NoLegend() + plot2 + NoLegend()
# Using celldex and SingleR packages.
# Download reference data from celldex.
reference <- HumanPrimaryCellAtlasData()
# Join layers before conversion. SingleR uses the RNA assay.
merged.SCexp <- JoinLayers(SCP_data, assay = "RNA")
# Convert Seurat object into a SingleCellExperiment Object for SingleR input.
merged.SCexp <- as.SingleCellExperiment(merged.SCexp)
SingleR.annotation <- SingleR(test = merged.SCexp, ref = reference, assay.type.test = "logcounts", labels = reference$label.main, num.threads = detectCores())
SCP_data[["cell.labels"]] <- SingleR.annotation$labels
DimPlot(SCP_data, reduction = "umap", group.by = "cell.labels", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
# Obtaining a vector containing the cluster of each cell in order.
# Get the factor contained in the SeuratObject with all this information.
clusters <- SCP_data@meta.data[["seurat_clusters"]]
# The cluster information for each cell is contain as a factor which levels coincide with the total number of clusters found by FindClusters(). An approach to transform this factor into a character vector is the following:
# Obtain the list of clusters with levels(clusters). This outputs a character vector containing the levles of the factor. After that, we use the factor itself as an index to access the levels vector. When using a factor as an index, R does not use the labels itself (which in this case are string, so if used as indexes would cause an error), but the internal numeric index the factor contains. That way, for each cluster label associated with a cell in the factor, we access its numeric index and map it to the levels vectors (which coincides), thus obtaining each cell label as an unique character value. Each cell label is then storage as a character (the as.character is added as a control method since SingleR only admits strings as labels) in a vector. The vector contains the cluster label for each cell as a character value in the same order as each cell appears in the dataset, so the by-cluster annotation doesn't assign the cells to an incorrect cluster.
clusters <- as.character(levels(clusters)[clusters])
# reference <- HumanPrimaryCellAtlasData()
# merged.SCexp <- as.SingleCellExperiment(SCP_data)
# We input the cluster vector using the clusters parameter.
SingleR.annotation <- SingleR(test = merged.SCexp, ref = reference, assay.type.test = "logcounts", labels = reference$label.main, clusters = clusters, num.threads = detectCores())
SCP_data[["cluster.labels"]] <- SingleR.annotation$labels
# We composite the cluster name. That way when 2 clusters' names are the same Seurat doesn't merge the labels.
# Get clusters levels accessing the SeuratObject variable as a df and then accessing the df as a column.
cluster_number <- levels(SCP_data[["seurat_clusters"]][1, ])
# Get annotation labels.
cluster_annotation <- SingleR.annotation$labels
# Since cluster levels and labels are in the same order, we composite the new names using paste0 (sort of equivalent to fstrings in python).
new.clusters.ids <- paste0(cluster_number, "-", cluster_annotation)
# Add names to each value of the clusters id vector so Seurat can take it as a valid input for RenameIdents.
names(new.clusters.ids) <- levels(SCP_data)
SCP_data <- RenameIdents(SCP_data, new.clusters.ids)
SCP_data[["cell.cluster.labels"]] <- Idents(SCP_data)
DimPlot(SCP_data, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
# Sumarize() performs an operation over a row of a dataframe, for example mean() or count n().
# Slots are dataframes, so it can be used by dplyr.
prop_cell_by_sample <- SCP_data@meta.data %>% group_by(Sample_Name, cell.cluster.labels) %>%
summarise(n = n()) %>% # For each cluster, group the cells from the same sample together and count them.
ungroup() %>% group_by(Sample_Name) %>%
mutate(freq = n / sum(n)) %>% # Group them now by sample, add up the total number of cells from that sample (regardless of the cluster they belong to). Then, divide each n value (number of cells of a sample in a certain cluster), obtaining which fraction of the total cells of that given type is present on each cluster.
left_join(SCP_data@meta.data %>% select(Sample_Name, Sample_Group) %>% unique()) # Add metadata info available for the data, select only the Sample_Name and Sample_Group fields and delete duplicates.
# Filter only the desired groups "N" and "T"
prop_cell_by_sample_filtered <- prop_cell_by_sample %>%
filter(Sample_Group %in% c("N", "T"))
# Extract data for Sample_Group "T" and other groups
group_T <- prop_cell_by_sample[prop_cell_by_sample$Sample_Group == "T", ]
group_N <- prop_cell_by_sample[prop_cell_by_sample$Sample_Group == "N", ]
# Perform t-test for each cluster
clusters <- levels(prop_cell_by_sample$cell.cluster.labels)
p_values <- numeric(length(clusters))
for (i in seq_along(clusters)) {
cluster_data_T <- group_T[group_T$cell.cluster.labels == clusters[i], "freq"]
cluster_data_N <- group_N[group_N$cell.cluster.labels == clusters[i], "freq"]
# Perform test
test_result <- wilcox.test(cluster_data_T$freq, cluster_data_N$freq)
# Store p-value
p_values[i] <- test_result$p.value
}
# Identify clusters with significant enrichment (e.g., p-value < 0.05)
enriched_clusters <- clusters[p_values < 0.05]
# Print or visualize the enriched clusters
print(enriched_clusters)
print(p_values)
# Plot only the desired groups
enriched_clusters <- ggboxplot(prop_cell_by_sample_filtered, x = "Sample_Group", y = "freq",
color = "Sample_Group",  palette = "jco",
add = "jitter") +
facet_wrap(~cell.cluster.labels, scales = "free", nrow = 6) +
theme(legend.position = "none") +
xlab("Sample Group") + ylab("Frequency") +
stat_compare_means(aes(label = ..p.signif..), label.x = 1.5)
enriched_clusters
# By-cell method (uses integrated and SCTransformed data)
SCP_data <- PrepSCTFindMarkers(SCP_data)
cluster18.markers.cell <- FindMarkers(SCP_data, ident.1 = "T", ident.2 = "N", group.by = "Sample_Group", subset.ident = "18-T_cells", assay = "SCT", recorrect_umi = FALSE)
# Using pseudobulk.
bulk <- AggregateExpression(SCP_data, return.seurat = T, slot = "counts", assays = "RNA", group.by = c("seurat_clusters",
"Sample_Name", "Sample_Group"))
# We don't know why it adds a "g" after pseudobulking.
cluster18 <- subset(bulk, seurat_clusters == "g18")
# As we are using bulks instead of cells, we need to change the test to a more appropiate one.
cluster18.markers.bulk <- FindMarkers(cluster18, ident.1 = "T", ident.2 = "N", group.by = "Sample_Group", test.use = "DESeq2")
FC = log2(1.5) # Set FC threshold.
# Add a column to the data frame to specify if they are UP- or DOWN- regulated (log2fc respectively positive or negative).
cluster18.markers.cell$diffexpressed <- "NO"
# if FC > 1.5 (log2FC > ~0.6) and pvalue < 0.05, set as "UP".
cluster18.markers.cell$diffexpressed[cluster18.markers.cell$avg_log2FC > FC & cluster18.markers.cell$p_val < 0.05] <- "UP"
# if FC < 0.666 (invers 1/1.5 calculated as log2FC < ~-0.6) and pvalue < 0.05, set as "DOWN".
cluster18.markers.cell$diffexpressed[cluster18.markers.cell$avg_log2FC < -FC & cluster18.markers.cell$p_val < 0.05] <- "DOWN"
cluster18.markers.cell <- cluster18.markers.cell %>%
arrange(p_val) %>%
mutate(gene_symbol = rownames(.)) %>%
group_by(diffexpressed) %>%
mutate(delabel = if_else(diffexpressed %in% c("UP", "DOWN") & row_number() <= 10, gene_symbol, NA)) %>%
ungroup()
cell.DE <- ggplot(cluster18.markers.cell, aes(x = avg_log2FC, y = -log10(p_val), col = diffexpressed, label = delabel)) +
geom_vline(xintercept = c(-FC, FC), col = "grey", linetype = 'dashed') +
geom_hline(yintercept = -log10(0.05), col = "grey", linetype = 'dashed') +
geom_point(size = 2) +
scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable
labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
labs(color = NULL, #legend_title,
x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) +
theme_classic() +
scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
geom_text_repel(box.padding = 0.6, max.overlaps = Inf) # To show all labels
# Add a column to the data frame to specify if they are UP- or DOWN- regulated (log2fc respectively positive or negative).
cluster18.markers.bulk$diffexpressed <- "NO"
# if FC > 1.5 (log2FC > ~0.6) and pvalue < 0.05, set as "UP".
cluster18.markers.bulk$diffexpressed[cluster18.markers.bulk$avg_log2FC > FC & cluster18.markers.bulk$p_val < 0.05] <- "UP"
# if FC < 0.666 (invers 1/1.5 calculated as log2FC < ~-0.6) and pvalue < 0.05, set as "DOWN".
cluster18.markers.bulk$diffexpressed[cluster18.markers.bulk$avg_log2FC < -FC & cluster18.markers.bulk$p_val < 0.05] <- "DOWN"
cluster18.markers.bulk <- cluster18.markers.bulk %>%
arrange(p_val_adj) %>%
mutate(gene_symbol = rownames(.)) %>%
group_by(diffexpressed) %>%
mutate(delabel = if_else(diffexpressed %in% c("UP", "DOWN") & row_number() <= 10, gene_symbol, NA)) %>%
ungroup()
bulk.DE <- ggplot(cluster18.markers.bulk, aes(x = avg_log2FC, y = -log10(p_val), col = diffexpressed, label = delabel)) +
geom_vline(xintercept = c(-FC, FC), col = "grey", linetype = 'dashed') +
geom_hline(yintercept = -log10(0.05), col = "grey", linetype = 'dashed') +
geom_point(size = 2) +
scale_color_manual(values = c("#00AFBB", "grey", "#bb0c00"), # to set the colours of our variable
labels = c("Downregulated", "Not significant", "Upregulated")) + # to set the labels in case we want to overwrite the categories from the dataframe (UP, DOWN, NO)
labs(color = NULL, #legend_title,
x = expression("log"[2]*"FC"), y = expression("-log"[10]*"p-value")) +
theme_classic() +
scale_x_continuous(breaks = seq(-10, 10, 2)) + # to customise the breaks in the x axis
geom_text_repel(box.padding = 0.6, max.overlaps = Inf) # To show all labels
cell.DE + bulk.DE
sessionInfo()
RNGkind()
