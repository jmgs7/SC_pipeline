---
title: "run4_analysis"
author: "José Manuel Gómez Silva"
date: "`r Sys.Date()`"
output: # html_notebook
---

```{r setup, include=FALSE}
all_times <- list() # store the time for each chunk
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      now <<- Sys.time()
    } else {
      res <- difftime(Sys.time(), now, units = "secs")
      all_times[[options$label]] <<- res
    }
  }
}))

knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE,
  error = TRUE,
  echo = TRUE,
  engine.opts = list(bash = "-l")
)
```

# SC_Prostate_Run_4 analysis.

Analyiis of scRNA-seq data provided by Eduardo Andrés León (eduardo.andres\@csic.es, Instituto de Parasitología y Biología López Neyra, Granada). SC data was generated and pre-analysed sing BD Rhapsody systems and Illumina sequencers. BD includes pipelines for read mapping and putative cell filtering.

```{r libraries, include = FALSE}
library(Seurat)
library(dplyr)
library(patchwork)
library(sctransform)
library(ggplot2)
library(celldex) # Cell annotation.
library(SingleR) # Cell annotation.
library(parallel) # detectCores()
library(future) # Allows parallelization in Seurat.
library(readODS) # Allows ods file import to add sample info
# Set up Seurat pararell computing.
options(parallelly.fork.enable = TRUE)
plan("multicore", workers = detectCores())
```

## 1. Import data and exploratory analysis.

```{r import_raw_data}
run4.raw <- readRDS("~/Documents/SC_Prostate/Data/run4/C4_expected.rds")
run4.raw
```

## 2. QC.

We will use the raw data in order to visualize QC parameters.

### 2.1. Mitochondrial gene percentage calculation.

```{r mito_genes}
run4.raw[["percent.mt"]] <- PercentageFeatureSet(run4.raw, pattern = "^MT-")

run4.raw[["percent.mt"]][1:5, ]
```

### 2.2. QC visualization.

What we can appreciate is a high proportion of cells with abundance of mitochondrial genes. Also, the distribution of the number of genes per cells shows an strange distribution, with a group of cells containing a low count fo features.

We can appreciate that the sample preprocessing done by the sequencing systems has automatically trimmed cells with less than 5K counts. Nevertheless, we suspect we could be losing important data, as the distribution of the read counts seems to have been cut right in the center of the curve.

The plotting of the % mitochondrial genes against read count shows a very disperse distribution, while the slope between counts and features is quasi linear.

```{r QC_visualization, fig.height=6, fig.width=10}
# Visualize QC metrics as a violin plot
VlnPlot(run4.raw, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Zoom in on nFeature_RNA violin plot.
VlnPlot(run4.raw, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()

# Zoom in on nCount_RNA violin plot.
VlnPlot(run4.raw, features = "nCount_RNA", ncol = 1) + ylim(0, 25000) + NoLegend()

# Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run4.raw, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(run4.raw, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

### 2.3. Filtering cells.

#### A. Filtering 1 % top and bottom percentiles.

Taking into account the observed QC parameters and our reduces number of cells, we suggest a soft data-driven filtering method. In our case, we trimmed out the top and bottom 1% of cells according to their gene count, and apply a %mito cutoff of 25%.

```{r filtering_percentiles}
# Remove Undetermined and multiplets.
run4.subset <- subset(run4.raw, Sample_Tag != "Undetermined" & Sample_Tag != "Multiplet")

# Filter the 1% top and bottom percentiles.
minCov <- 1000 # if a sample has a good coverage (>=minCov), then don't set a lower thresold for nCount, it's already pretty good.
if (min(run4.subset$nCount_RNA) >= minCov) {
  countLOW <- min(run4.subset$nCount_RNA)
} else {
  countLOW <- quantile(run4.subset$nCount_RNA, prob = c(0.01))
}
countHIGH <- quantile(run4.subset$nCount_RNA, prob = 0.99)
featureHIGH <- quantile(run4.subset$nFeature_RNA, prob = 0.99)
featureLOW <- quantile(run4.subset$nFeature_RNA, prob = 0.01)

# subset
run4.subset <- subset(run4.subset, subset = nFeature_RNA > featureLOW & nFeature_RNA < featureHIGH & nCount_RNA > countLOW & nCount_RNA < countHIGH & percent.mt < 25)

run4.subset
```

### 2.4. Adding sample names and sample groups.

```{r}

# Load information from .ods file
excel_data <- read_ods("~/Documents/SC_Prostate/Data/sample_info.ods")

# Specify the experiment you want to extract information for
target_run <- "run4"

# Filter Excel data for the specific experiment
filtered_excel_data <- excel_data %>%
  filter(Run == target_run)

# Extract the numeric part from Sample Tag and convert it to integer
run4.subset$Sample_Tag_Number <- as.integer(gsub("\\D", "", run4.subset$Sample_Tag))

# Extract Sample Name and Sample Group based on Sample Tag information
run4.subset$Sample_Name <- filtered_excel_data$Sample_Name[match(run4.subset$Sample_Tag_Number, filtered_excel_data$Sample_Tag)]

run4.subset$Sample_Group <- filtered_excel_data$Sample_Group[match(run4.subset$Sample_Tag_Number, filtered_excel_data$Sample_Tag)]

run4.subset$Sample_Name_Group <- filtered_excel_data$Sample_Name_Group[match(run4.subset$Sample_Tag_Number, filtered_excel_data$Sample_Tag)]
```

```{r saving_filtered_data, include = FALSE, echo = FALSE}

# Save filtered file for data merging.
saveRDS(run4.subset, file = "~/Documents/SC_Prostate/Data/run4/run4_filtered.rds")
```

### 2.5. Normalization using SCTransform.

We normalize data using the new SCTransform methodology. This methodology is more precise, more friendly with the original data structure, and offers better clustering results.

The vars.to.regress parameter allows to regress out certain variables, preventing them to have a high impact on PCA dimension reduction and further clustering of samples.

```{r SCTransform}

run4.subset <- SCTransform(run4.subset, vst.flavor = "v2", vars.to.regress = "percent.mt")
```

### 2.6. Visualizing QC parameters after normalization.

After filtering and normalization we can see that the distribution of mitochondrial DNA improves a bit, and the ration between counts and features is closer to a linear function.

Another thing that don't make sense is the long upper tails of the features and counts distribution. Maybe is possible to apply a more strict cut, but we have to remember we have a low number of cells and there is more data yet to be added.

```{r QC_norm, fig.height=6, fig.width=10}
# Visualize QC metrics as a violin plot
VlnPlot(run4.subset, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# Zoom in on nCount_RNA violin plot.
VlnPlot(run4.subset, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500)

# Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run4.subset, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(run4.subset, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + plot2
```

## 4. Linear dimensional reduction (PCA).

```{r PCA, fig.height=6, fig.width=10}

# Run PCA on the SCT-normalyzed data.
run4.subset <- RunPCA(run4.subset, assay = "SCT") # features = VariableFeatures(object = run4.subset))

DimPlot(run4.subset, reduction = "pca") + NoLegend() # An unique PCA is not enough to separate cell groups.

ElbowPlot(run4.subset, ndims = 50)
```

In normal circumstances, a selection of the first 10 dims would be enough, but the Seurat developers recommend using a higher amount of PCA dims when using SCTransform.

```{r PCA_heatmap, fig.height=15, fig.width=10}
DimHeatmap(run4.subset, dims = 1:30, balanced = TRUE)
```

```{r PCA_top_features, fig.height=30, fig.width=15}
VizDimLoadings(run4.subset, dims = 1:30, reduction = "pca")
```

## 5. Clustering.

### 5.1. Cluster computation.

```{r clustering}
# Resolution fine-tuned in a separate Rmd.
run4.subset <- FindNeighbors(run4.subset, dims = 1:30)
run4.subset <- FindClusters(run4.subset, resolution = 0.8) # Default resolution = 0.8
run4.subset <- RunUMAP(run4.subset, dims = 1:30)
```

```{r cluster_visualization, fig.height=6, fig.width=10}
DimPlot(run4.subset, reduction = "umap", label = TRUE)
```

### 5.2. Cluster QC.

As we can observe, the data structure is conditioned by the abundant presence of mitochondrial DNA. Taking into account the cluster with less % of mitochondrial DNA, cluster 17, we appreciate how the lower content in mitochondrial material correlates with lower feature and read counts. On the other hand, if we compare the distritrubution of mitoDNA of each cluster with the feature and count distribution, we can see a clear similarity.

Thus, mitochondrial DNA is shaping the data, and probably conditioning the cell annotation and further analysis.

```{r cluster_QC, fig.height=6, fig.width=10}
# Visualize QC metrics as a violin plot
VlnPlot(run4.subset, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) + NoLegend()

# Zoom in on nFeature_RNA violin plot.
VlnPlot(run4.subset, features = "nFeature_RNA", ncol = 1) + ylim(0, 2500) + NoLegend()

# Visualize relationships in metadata to detect outliers with FeatureScatter function
plot1 <- FeatureScatter(run4.subset, feature1 = "nCount_RNA", feature2 = "percent.mt")
plot2 <- FeatureScatter(run4.subset, feature1 = "nCount_RNA", feature2 = "nFeature_RNA")
plot1 + NoLegend() + plot2 + NoLegend()
```

## 6. Annotation.

Cell annotation is performed using the Human Cell Atlas as reference.

SingleR.annotation uses the logcounts provided in the count matrix of the SingleCellExperiment object by default. Nevertheless, after applying SCTransform, counts and logcounts are both the normalized counts (so both values are the same).

```{r annotation}
# Using celldex and SingleR packages.
# Download reference data from celldex.
reference <- HumanPrimaryCellAtlasData()

# Convert Seurat object into a SingleCellExperiment Object for SingleR input.
run4.SCexp <- as.SingleCellExperiment(run4.subset)

# Anotate using raw counts.
SingleR.annotation <- SingleR(test = run4.SCexp, ref = reference, assay.type.test = "logcounts", labels = reference$label.main, num.threads = detectCores())

run4.subset[["cell.labels"]] <- SingleR.annotation$labels
```

```{r annotation_vis, fig.height=6, fig.width=10}
DimPlot(run4.subset, reduction = "umap", group.by = "cell.labels", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
```

You can also obtain the anotation on a cluster-by-cluster method based rather than a cell-by-cell one. By cluster annotation:

```{r}
clusters <- run4.subset@meta.data[["seurat_clusters"]]
clusters <- as.character(levels(clusters)[clusters])
```

```{r cluster_annotation}
# Obtaining a vector containing the cluster of each cell in order.

# Get the factor contained in the SeuratObject with all this information.
clusters <- run4.subset@meta.data[["seurat_clusters"]]

# The cluster information for each cell is contain as a factor which levels coincide with the total number of clusters found by FindClusters(). An approach to transform this factor into a character vector is the following:
# Obtain the list of clusters with levels(clusters). This outputs a character vector containing the levles of the factor. After that, we use the factor itself as an index to access the levels vector. When using a factor as an index, R does not use the labels itself (which in this case are string, so if used as indexes would cause an error), but the internal numeric index the factor contains. That way, for each cluster label assosiated with a cell in the factor, we access its numeric index and map it to the levels vectors (which coincides), thus obteinin each cell label as an unique character value. Each cell label is then storage as a character (the as.character is added as a control method since SingleR only admits strings as labels) in a vector. The vector contains the cluster label for each cell as a character value in the same order as each cell appears in the dataset, so the by-cluster annotation doesn't assing the cells to an incorrect cluster.
clusters <- as.character(levels(clusters)[clusters])

# reference <- HumanPrimaryCellAtlasData()

run4.SCexp <- as.SingleCellExperiment(run4.subset)

# We input the cluster vector using the clusters parameter.
SingleR.annotation <- SingleR(test = run4.SCexp, ref = reference, assay.type.test = "logcounts", labels = reference$label.main, clusters = clusters, num.threads = detectCores())

run4.subset[["cluster.labels"]] <- SingleR.annotation$labels
```

```{r set_ids}
# We composite the cluster name. That way when 2 clusters name are the same Seurat doesn't merge the labels.

# Get clusters levels accesing the SeuratObject variable as a df and then accesing the df as a column.
cluster_number <- levels(run4.subset[["seurat_clusters"]][1, ])

# Get annotation labels.
cluster_annotation <- SingleR.annotation$labels

# Since cluster levels and labels are in the same order, we composite the new names using paste0 (sort of equivalent to fstrings in python).
new.clusters.ids <- paste0(cluster_number, "-", cluster_annotation)

# Add names to each value of the clusters id vector so Seurat can take it as a valid input for RenameIdents.
names(new.clusters.ids) <- levels(run4.subset)
run4.subset <- RenameIdents(run4.subset, new.clusters.ids)
```

```{r cluster_annotation_vis, fig.height=6, fig.width=10}
DimPlot(run4.subset, reduction = "umap", label = TRUE, repel = TRUE, label.size = 4) + theme(axis.title = element_text(size = 15), legend.text = element_text(size = 10), axis.text = element_text(size = 10)) + guides(colour = guide_legend(override.aes = list(size = 3)))
```

```{r saving_data, include = FALSE, echo = FALSE}

# Save fully-proccesed data.
saveRDS(run4.subset, file = "~/Documents/SC_Prostate/Output/run4/run4_processed.rds")
```
